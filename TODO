todo:
3) Write the test cases for the tuple classes. Add tests for the iterators too.
4) Work how how the bit array class can be used to provide sub-int channels.





1) Complete the interface of the PixelLayout class to match the other layouts. This may require adding a LayoutTraits method to all the other layouts too.

Finish the implementation of the PixelLayout and add the test cases for it. It should have the same interface as the other Layout clases.

Move the tuple code into it's own file.

Add test cases for the tuple code and create the tuple specialization that allows a single int to be used for RGB.

Create the DynamicLayout class and the test cases for it.

Extend the pixelLayout class so that it only accepts a DynamicLayout as the first template argument. Write test cases for it.

Write the PixelBase class. It should accept a Layout class as the only template parameter. It should recursively derive from itself and create a member.
E.G
template< class Layout > class PixelBase : PixelBaseRecurse< Layout, Layout::NumberOfLayouts>
{
   PixelBase()
    {
        We should assert that there are no dynamic channels here. If there are then the other constructor needs to be used.
    }
    PixelBase( Layout L ) : m_layout( L )
    {
    }

    private:
       Layout m_layout;
}
template< class Layout, unsigned Index > class PixelBaseRecurse : PixelBaseRecurse< Layout, Index - 1>
{
	    Tuple< typename LayoutTraits<Index>::StorageType, LayoutTraits<Index>::NumberOfChannels >
}

Add ChannelTraits methods to the PixelBase.

Add methods for accessing the values of the channel data using either an index by the channel index or the ChannelDefault.

Add methods for adding channels. If the Layout is not dynamic, then assert a Static assertion.

Typedef the PixelBase with tuples that hold values and not pointers as a Pixel.

Derive from PixelBase to create the PixelAccessor. This class should add increment and decrement methods along with the methods required to set the pointers (requiredChannels and setChannelPointer) .







2)
Change the RunTimeChannelFormat class to hold a value for ChanIndexToStep, ChanIndexToOffset and ChanIndexToPtrIndex. These types should be of size EnumType.
These values can then be used in the pointerIndex( index ), step( index ) and pointerOffset( index ) methods in the same way that the ChannelFormat currently does.
Use the bit twiddler class to access them as if they are arrays.
Change the pointerIndex( channel ), step( channel ) and pointerOffset( channel ) methods to work out the index of the channel and look it up from the ChanIndexToStep, ChanIndexToOffset
and ChanIndexToPtrIndex bit arrays.

3)
The purpose of the CompileTimeChannelFormat class is that it should be possible to write a method that constucts one from a RunTimeChannelFormat. This method can then be used within the operate()
method of the ops. Write this method so that it constructs a CompileTimeChannelFormat from a RunTimeChannelFormat before calling compute().

4) Write an Iterator wrapper class to give an interface which can use the accessor
class as a base to implement iteration over a row.

5) Write the Image wrapper which also uses the pixel accessor as it's base. It should
be able to add channels to the list of pointers. This should be implemented as a 
addChannelPointer method on the pixel accessor base classes. In the case of the runtime
base, the pointer should be inserted and the runtime Channel format class updated.
In the case of the compile time pixel accessor, the addChannelPointer method should
assert that the pointer it is adding to is null and if not, raise an exception.

Use the requiredChannelPointers() method on the format and accessor classes to get a ChannelSet
or the channels that require pointers before looping over them and setting the pointer values.

>  Rebase against OIIO master.
>  The OIIO lib and src dependencies to GanderImage. E.G:
>
>  388     "GanderImage" : {
	>  389         "install" : True,
	>  390         "envAppends" : {
		>  391             "LIBS" : [
		>  392                 "OpenImageIO$OIIO_LIB_SUFFIX",
		>  393                 "dl"
		>  394             ],
		>  395             "requiredOptions" : [ "OIIO_SRC_DIR", "OCIO_SRC_DIR" ],
		>  396         }
		>  397     },
		>

6) Implement some basic pixel operations to see how well it works.

7) As we can now launch ops with a CompileTimeChannelFormat, it may not be neccessary to have the ChannelFormat and ChannelFormatBase classes at all. They are still useful if we want to explicitly
define the format of an image outside of an Op but otherwise, it is probably easier to just use a RunTimeChannelFormat class. To this end, work out a better naming scheme for all of the ChannelFormat
classes so that we don't need to use the RunTimeXXX and CompileTimeXXX names. 

